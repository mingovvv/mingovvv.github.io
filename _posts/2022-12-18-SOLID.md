---
title: 객체지향 프로그래밍 SOLID
author: mingo
date: 2022-12-18 23:21:09 +0900
categories: [java]
tags: [java, oop, solid]
---

----

## SOLID란?
프로그래밍을 좀 더 객체지향답게(?) 사용하기 위한 소프트웨어 아키텍쳐 및 설계 원칙의 모음을 원칙의 앞 글자만 따서 **SOLID** 라고 불리운다.
이러한 원칙은 소프트웨어의 가이드라인을 제공하고 코드의 유지 보수성, 확장성, 가독성을 향상시키는데 도움을 준다. 각 원칙에 대하여 가볍게 알아보자.

## 단일 책임 원칙(Single Responsibility Principle, SRP)
**단일 책임 원칙은 클래스 또는 모듈이 오직 하나의 책임을 가져야 한다는 원칙이다.** 이 말은 객체는 목적이 명확하게 드러나도록 정의해야 한다는 것과 마찬가지라고 생각한다.
하나의 클래스에서 여러 관심사나 책임을 가지게 되면 자연스럽게 다른 객체와도 의존도가 높아질 수 밖에 없다. 
이것은 객체간에 높은 커플링이 발생하기에 하나의 객체가 다른 객체에 영향을 미칠 수 있는 상황을 초래할 가능성이 높다.

> 단일 책임, 분리된 관심사, 높은 응집도, 가독성 향상, 재사용성, 유지 보수성 향상
{: .prompt-tip }

> 과도한 분리로 인한 다수의 클래스
{: .prompt-danger }

## 개방-폐쇄 원칙(Open-Closed Principle, OCP)
**개방-폐쇄 원칙은 소프트웨어 클래스, 모듈, 함수는 확장에는 열려있고 수정에는 닫혀있어야 한다는 원칙이다.** 
이 말은 곧 새로운 기능이나 동작을 추가할 때, 기존 코드를 수정하지 않고 추가할 수 있어야 한다는 것을 의미한다.
코드는 안정성을 유지하게 되고 수정에 닫혀 있으니 변경에 따른 위험을 최소화 할 수 있다.

> 코드의 안정성 유지, 재사용성 증가, 유지 보수성 향상
{: .prompt-tip }

> 추상화 및 조금 더 높은 수준의 설계, 설계 복잡성 증가
{: .prompt-danger }

## 리스코프 치환 원칙(Liskov Substitution Principle, LSP)
**리스코프 치환 원칙은 자식타입은 부모타입을 대체할 수 있어야 한다는 원칙이다.**
자식클래스는 부모클래스의 인터페이스 즉, 설계를 준수하고 부모클래스의 기능을 깨트리거나 변경하지 않는 선에서 **확장**하는 것을 말한다.
여기서 중요한 것은 확장인데, 부모의 메서드를 상속받아서 마음대로 쓰지말라는 것이다. 부모의 메서드를 자식이 오버라이딩한다면 기능적인 추가가 발생해야하는 것이지 쌩뚱맞은 기능이 들어가서 부모 클래스의 메서드에 타격을 입히면 안된다.
리스코프 치환 원칙이 깨지면 클라이언트 코드가 예상치 못한 결과를 가져올 수 있다.

> 다형성 지원, 유지 보수성 향상
{: .prompt-tip }

> 추상화 및 조금 더 높은 수준의 설계, 설계 복잡성 증가
{: .prompt-danger }

## 인터페이스 분리 원칙(Interface Segregation Principle, ISP)
**인터페이스 분리 원칙은 클라이언트가 사용하지 않는 메서드에 의존하지 않도록 인터페이스를 구체적으로 분리하라는 원칙이다.**
하나의 큰 인터페이스보다 여러러 개의 작은 인터페이스가 더 나은 설계로 간주하는 원칙이다.

> 의존성 감소(느슨한 커플링), 가독성 향상, 유지 보수성 향상
{: .prompt-tip }

> 인터페이스 증가, 설계 복잡성 증가
{: .prompt-danger }

## 의존성 역전 원칙(Dependency Inversion Principle, DIP)
**의존성 역전 원칙은 높은 수준의 모듈은 낮은 수준의 모듈에 의존해서는 안되며, 객체는 추상화에 의존해야 한다는 원칙이다.**
시스템을 높은 수준, 낮은 수준의 모듈로 분할하고 높은 수준은 낮은 수준의 모듈에 의존해서는 안된다. 
또한 두 모듈 모두 인터페이스 또는 추상클래스 같은 추상화에 의존해야 모듈간 결합성을 낮추고 유연성을 향상시키는 방법이다.

> 의존성 감소(느슨한 커플링), 유연성
{: .prompt-tip }

> 추상화 증가, 설계 복잡성 증가
{: .prompt-danger }

## 마무리
사실 사내 업무 비즈니스 로직을 만지다보면 SOLID 원칙이 깨져있는 것을 쉽게 찾아볼 수 있다. (수정에 너무 열려있다ㅠㅠㅠ)
아무래도 실제 업무는 시간과 일정이 항상 촉박하게 주어지다보니, 고대로부터 전해 내려오는 코드를 미처 수정하지 못하고 덧붙이기식 짬뽕 코드로 점점 변해가는 거라고 생각한다.
6천 라인이 넘는 클래스를 보면서 건드릴 엄두가 안나서 카피 & 페이스트를 하게 된다. 처음 설계가 얼마나 중요한지 한번 더 느낄 수 있는 경험이었다.
