---
title: 👨‍🔧 REDIS 캐시로 인한 장애.. 그리고 리팩토링
author: mingo
date: 2022-12-18 23:21:09 +0900
categories: [troubleshooting, redis]
tags: [redis]
---

-----

## 문제 발생
우리팀은 redis를 RDBMS를 통해 조회된 데이터를 캐싱 처리 하여 사용하고 있다. 
매장 단위로 고유한 값을 키(Key)로 설정하고 매장의 재고 정보(Object)를 값(Value)으로 만들어서 사용자로 하여금 빠른 데이터 엑세스를 가능하게 하였다. 
이것은 실시간 매장 재고 조회의 Latency를 줄이고 라이브 DB의 부하를 낮추는 목적으로 설계되었다.

문제 발생은 재고 서비스에 다른 협력사가 추가되면서 신규 페이로드 추가 요청으로 재고 정보(Object)에 새로운 필드를 추가하면서 발생했다. 
해당 기능이 배포되고 모든 재고 정보를 읽지 못하여 결국 장애로 이어지는 대참사가 발생했다. 따흐흑

## 문제 원인
재고 서비스는 두 대로 구성되어 있으며 A-서비스는 재고 정보 갱신을 담당하고 B-서비스는 재고 정보 조회를 독립적으로 나뉘어서 담당하고 있었다. 
페이로드 추가는 A-서비스 DTO에 추가되었고 실제 문제는 B-서비스에서 발생했다. 
직접적인 원인은 A-서비스에서 새롭게 추가된 필드를 B-서비스에서는 추가해주지 않아 역직렬화를 시도하다가 알려지지 않은 필드가 있기 때문에 
SerializationException 에러가 발생한 것이다.

A-서비스 담당자가 이것을 캐치하지 못했던 이유는 아래와 같다.
스프링부트는 객체를 직렬화/역직렬화 할 때 기본적으로 Jackson 라이브러리를 사용한다.
부트는 역직렬화 시, Jackson 라이브러리의 옵션을 변경해서 알려지지 않은 필드(`UNKNOWN_PROPERTIES`)에 대해서 무시하는 옵션을 default로 채택하고 있기 때문이다.

즉, A-서비스에 추가된 필드로 직렬화된 객체를 B-서비스에서 읽어도 알려지지 않은 필드(`UNKNOWN_PROPERTIES`)에 대해서는 무시될 거라고 생각했던 것이었다.

하지만, redis는 내부적으로 ObjectMapper를 새롭게 생성하여 스프링부트의 기본 옵션을 선택하지 않기에 알려지지 않은 필드가 있다면 exception을 발생한다.
A-서비스에 추가된 필드를 B-서비스에서는 추가되지 않았으므로 역직렬화 실패되고 exception이 발생하여 catch문을 통해 빈 깡통 DTO 객체만 조회 시 응답으로 내려갔던 것이였다.

## 문제 후속 조치
우선 B-서비스에 필드를 추가하는 것으로 상황을 해결은 하였지만, 오래된 redis 설정을 보면서 추가적인 개선을 진행하였다.

A-서비스, B-서비스는 모두 스프링 프레임워크에서 지원하는 `GenericJackson2JsonRedisSerializer` 클래스를 기반으로 Json 형식으로 포맷팅하는 직렬화 & 역진렬화 전략을 사용하고 있었는데, 
`GenericJackson2JsonRedisSerializer`는 직렬화 과정에서 **클래스 타입을 별도로 지정해주지 않아도 자동으로 객체를 Json으로 직렬화 해주는 장점**이 있지만, 역직렬화 시, 동일한 패키지의 경로에 객체가 존재해야만 한다는 단점도 있다.

![Desktop View](/assets/img/post/202202/1.png){: width="300" height="300" }
_redis-cli_

key에 해당하는 value는 `{"@class":"redis.test.dto.TestDto","username":"mingo","age":99}` 이며, 직접 추가한 field 이외에 `@class`라는 이름으로 클래스 패키지 경로가 값으로 등록되어 있는 것을 볼 수 있다. 
이 `@class`의 정체는 무엇이고 왜 들어가 있는 걸까?

`@class`는 `GenericJackson2JsonRedisSerializer` 클래스가 진행하는 직렬화 프로세스에서 알수 있듯이 `클래스 타입을 별도로 지정하지 않으니, 자체적으로 redis에 패키지 경로를 포함한 클래스`를 데이터화 하여 저장해버리는 것이다.
이러한 이유로 패키지 및 클래스의 정보를 key-value 쌍마다 가지고 있는것이며, 역직렬화 할 때 @class를 참조하여 사용하는 것이다.

A-서비스, B-서비스 패키지 경로와 클래스명을 일치시켜주면 문제 없겠지만 결론적으로 `Jackson2JsonRedisSerializer` 객체를 사용하는 것으로 전면 수정하기로 하였다. 이유는 다음과 같다.
1. 메모리 절약 측면 : redis의 `@class` 필드와 패키지 경로를 제거하여 메모리를 줄이기 위하여 
2. 유연한 설계 : 패키지 및 클래스 정보가 일치해야만 하는 설계에서 벗어나기 위하여

(`Jackson2JsonRedisSerializer`는 타입을 역직렬화 시, 사용할 타입을 미리 지정해주고 멀티스레드 환경에서 타입에러가 발생할 수 있기 때문에 조심히 써야한다. 내부적으로 RedisCacheManager와 RedisCacheConfiguration를 사용해서 반환 타입별로 캐시이름을 가지고 독립적인 Jackson2JsonRedisSerializer 객체가 사용되도록 설계하였다.)

## 마무리
작은 이슈로 시작된 커다란 장애로 모두가 슬픈..날이었다. 직접적인 원인을 수정하는 과정도 좋았지만 그보다 재발방지 및 소스 개선을 위해 머리를 맞대고 생각하는 시간이 더 와닿는 순간이었다. 
개발은 A가 더 좋다, B가 더 좋다는 일방적인 생각보다는 여러가지 대안이 있다면 나에게 제일 잘 맞는 옷을 입는게 중요한 것 같다.
