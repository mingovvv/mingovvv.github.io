---
title: 쿠버네티스 Pod 오브젝트 살펴보기
author: mingo
date: 2024-01-04 00:30:00 +0900
categories: [Kubernetes]
tags: [pod]
---

-----------------

## Pod LifeCycle
![1.png](/assets/img/post/202401/1.png){: .border .center-image w="600" h="800" }
_Pod와 Container의 라이프사이클_

쿠버네티스 최소배포 단위인 Pod는 하나 이상의 컨테이너로 구성되어 있으며, Pod의 상태는 Pod 내부의 컨테이너 상태에 따라 결정된다. 
Pod의 상태는 크게 4가지로 구분되는데 <kbd>Pending</kbd>, <kbd>Running</kbd>, <kbd>Failed</kbd>, <kbd>Succeeded</kbd> 이 4가지 상태는 Pod의 상태를 나타내는 Phase 필드에 반영된다.

Pod는 Pod의 라이프사이클 중에서 딱 한번만 Scheduled 되어 특정 Node에 할당되며 종료될 때까지 해당 Node에서 실행된다.

![10.png](/assets/img/post/202401/10.png){: .border .center-image w="500" h="400" }
_Pod 상태 조회 - phase 필드_
 - `kubectl get pod <name-of-pod> -o yaml`

- kubedoc - Pod LifeCycle : <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/>

### 1. Pending Phase
![2.png](/assets/img/post/202401/2.png){: .border .center-image w="800" h="400" }
쿠버네티스 클러스터에서 승인되고 나서 Pod의 최초 상태는 `Pending` 상태이며, 본 컨테이너가 기동되기 전에 Volume이나 보안 설정 등 초기화 시켜야하는 내용을 추가할 수 있는 `initContainer` 가 실행된다. 
(`initContainer`는 Pod 명세 안에 initContainers 항목으로 초기화 스크립트를 작성할 수 있다.) 
initContainer는 본 컨테이너보다 먼저 실행되고 성공적으로 초기화 작업이 종료되면 이어서 생성될 Pod가 어떤 Node에 할당될 지 결정하는 Pod Scheduling 작업이 수행된다. 
Node 결정 후에는 컨테이너의 이미지를 다운로드를 진행한다. (이때 컨테이너 상태는 waiting:ContainerCreating 상태이다.)

### 2. Running Phase
![3.png](/assets/img/post/202401/3.png){: .border .center-image w="800" h="400" }
  
본격적으로 컨테이너가 기동되면서 Pod는 Node에 바인딩된다. 이후 Pod와 Container의 상태는 `Running` 상태로 변경된다. 
만약 Pod 속 일부 Container에 문제가 생겨 재시작하면 Container의 상태는 waiting:CrashLoopBackOff가 되지만 
Container의 재시작과 관계없이 Pod는 Running 상태를 유지한다. 다만 Pod의 내부 컨디션의 `ContainerReady`와 `Ready` 필드는 false 상태가 된다.

> Pod 상태가 Running 이여도 내부 Container 상태에 문제가 있을 수 있으므로 내부 컨테이너 상태도 주목할 필요가 있다.
{: .prompt-warning }

Job이나 CronJob으로 생성된 Pod의 경우 자신의 일을 마치게 되면 Failed 또는 Succeeded 상태로 귀결된다.
참고로 둘 중 어느것이던지 Pod의 ContainerReady와 Ready는 false로 변경된다.

### 3-1 Failed Phase
작업을 하고 있는 컨테이너 중에 하나라도 문제가 발생하면 Pod의 상태는 Failed가 된다.
또한 Pending Status에서 정상적으로 Pod를 생성하지 못하고 Failed Status로 빠지는 케이스도 있다.

### 3-2 Succeeded Phase
작업을 하고 있는 컨테이너가 모두 작업을 성공적으로 Completed 하였을 경우 Pod의 단계는 Succeeded Status가 된다.

### 3-3 Unknown Phase
Running Status 중에 어떤 이유에 의해서 파드의 상태를 얻을 수 없게되면 Unknown Status로 변경된다.
이 단계는 일반적으로 Pod가 실행되어야 하는 Node와의 통신 오류로 인해 발생한다.

> Pod가 삭제될 때, 일부 kubectl 커맨드에서 `Terminating` 상태로 표시되는 경우가 있다. 이는 Pod가 삭제되기 전에 Pod 내부의 컨테이너가 gracefully한 종료를 위해 기다리는 상태이다. (default : 30s)
{: .prompt-info }

-----------------

## Container State

Pod의 phase뿐 아니라 Pod 내부의 Container 상태를 추적한다. 이를 위해 Container 상태를 나타내는 ContainerStatus 필드를 제공한다.
Container의 상태를 나타내는 필드는 <kbd>Waiting</kbd>, <kbd>Running</kbd>, <kbd>Terminated</kbd>가 있다.
각 단계는 해당 상태에 있는 이유를 요약하는 Reason 필드를 통해 상세한 상태를 나타낸다.

![11.png](/assets/img/post/202401/11.png){: .border .center-image w="500" h="400" }
_Container 상태 조회 - state 필드_
- `kubectl describe pod <name-of-pod>`

### 1. Waiting State
Running, Terminated 상태가 아닌 경우 Container의 상태는 Waiting 상태이다. waiting 상태는 컨테이너가 시작되고 이미지를 다운받거나 initContainer를 통해 초기화 작업을 진행하는 등 모든 필요한 작업을 실행하고 있는 중이다.

### 2. Running State
Container가 실행되고 있고, 컨테이너 내부의 프로세스가 실행되고 있는 상태이다.

### 3. Terminated State
Container가 완료될 때까지 실행되었거나 어떠한 이유로 실패되어 종료된 상태이다.

> Container는 자체 재시작 정책을 default로 가지고 있다. Pod를 생성할 때 `spec.restartPolicy ` 필드를 통해 `Always(default)`, `OnFailure`, `Never` 중 하나를 선택할 수 있다.
{: .prompt-tip } 


-----------------

## Prove
`Prove` 는 컨테이너에서 kubelet에 의해 주기적으로 수행하는 상태 검사이다. 상태 검사를 위해 kubelet은 컨테이너의 프로세스를 실행하고, 프로세스의 상태를 확인한다.

- kubedoc - Prove : <https://kubernetes.io/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%ED%94%84%EB%A1%9C%EB%B8%8C-probe>
- kubedoc - Readinessprobe & Livenessprobe : <https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>

### Readinessprobe
Container가 요청을 처리할 준비가 되었는지 여부를 나타낸다. `Readinessprobe`가 실패하면 엔드포인트 컨트롤러는 파드에 연관된 모든 서비스들의 엔드포인트에서 파드의 IP주소를 제거한다. 준비성 프로브의 초기 지연 이전의 기본 상태는 Failure 이다. 만약 컨테이너가 준비성 프로브를 지원하지 않는다면, 기본 상태는 Success 이다.

### Livenessprobe
Container가 동작 중인지 여부를 나타낸다. `Livenessprobe`가 실패하면 kubelet은 컨테이너를 재시작한다.

-----------------

## QoS
QoS는 Quality of Service의 약자로 Pod의 리소스 요청과 제한을 기반으로 Pod에 대한 우선순위를 결정한다.
쿠버네티스가 Pod를 생성할 때 BestEffort, Burstable, Guaranteed 3가지의 QoS 클래스 중 하나를 할당한다.

- kubedoc - QOS : <https://kubernetes.io/ko/docs/tasks/configure-pod-container/quality-service-pod/>

### 1. BestEffort QOS
`BestEffort QOS`는 컨테이너 리소스가 부족할 때 제거될 가능성이 가장 높은 클래스이다.

`BestEffort QOS` 클래스는 아래의 조건을 충족해야 생성된다.
 - Pod 내 모든 Container가 memory, cpu requests/limits를 명시하지 않았을 때
 
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: qos-demo-3
  namespace: qos-example
spec:
  containers:
    - name: qos-demo-3-ctr
      image: nginx
```

### 2. Burstable QOS
`Burstable QOS`는 리소스가 충분하지 않을 때 일부 리로스를 추가로 사용할 수 있다.

`Burstable QOS` 클래스는 아래의 조건을 충족해야 생성된다.
 - Pod가 Guaranteed QOS 클래스를 할당받지 못했을 때
 - Pod 내에서 최소한 하나의 컨테이너가 memory 또는 cpu requests/limits 를 명시했을 때

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: qos-demo-2
  namespace: qos-example
spec:
  containers:
  - name: qos-demo-2-ctr
    image: nginx
    resources:
      limits:
        memory: "200Mi"
      requests:
        memory: "100Mi"
```

### 3. Guaranteed QOS
`Guaranteed QOS`는 시스템의 리소스가 부족해도 리소스를 보장받는 클래스이다.

`Guaranteed QOS` 클래스를 할당받으려면 아래의 전제 조건을 충족해야 한다.
 - Pod 내 모든 Container는 spec.containers[].resources.requests, spec.containers[].resources.limits 필드를 통해 memory, cpu limits와 memory, cpu requests 명시해야 한다.
 - Pod 내 모든 Container는 명시한 memory, cpu limitsd와 memory, cpu requests가 동일해야 한다.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: qos-demo
  namespace: qos-example
spec:
  containers:
  - name: qos-demo-ctr
    image: nginx
    resources:
      limits:
        memory: "200Mi"
        cpu: "700m"
      requests:
        memory: "200Mi"
        cpu: "700m"
```

> Container spec을 명시할 때, memory, cpu limits를 지정하지만 requests를 지정하지 않으면 쿠버네티스는 requests를 limits와 동일하게 설정한다.
{: .prompt-tip }

-----------------

## Node Scheduling
Node Scheduler는 Pod를 어떤 Node에 할당할지 결정하는 컨트롤러이다.

### NodeName

### NodeSelector

### Node Affinity

### Pod Affinity

### Anti Affinity

### Toleration

### Taint

> source
- <https://www.inflearn.com/course/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B8%B0%EC%B4%88/>
- <https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/>
